<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shop Heater - Advanced Analysis</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 32px;
    }

    .nav-links {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .nav-links a {
      color: #fff;
      text-decoration: none;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      transition: background 0.3s;
    }

    .nav-links a:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .nav-links a.active {
      background: #9C27B0;
    }

    .section {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .section-title {
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #9C27B0;
      margin-bottom: 15px;
      font-weight: bold;
    }

    .controls-row {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      align-items: flex-start;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-group label {
      font-size: 13px;
      color: #aaa;
    }

    select, input[type="number"], input[type="text"] {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      padding: 10px 15px;
      border-radius: 4px;
      font-size: 14px;
      min-width: 180px;
    }

    select option {
      background: #1a1a2e;
      color: #fff;
    }

    select:focus, input:focus {
      outline: none;
      border-color: #9C27B0;
    }

    .checkbox-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      max-width: 600px;
    }

    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(255, 255, 255, 0.05);
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .checkbox-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .checkbox-item input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .checkbox-item label {
      font-size: 13px;
      cursor: pointer;
      color: #ddd;
    }

    .radio-group {
      display: flex;
      gap: 20px;
    }

    .radio-item {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .radio-item input[type="radio"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .chart-container {
      position: relative;
      height: 500px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      padding: 20px;
    }

    .stats-bar {
      display: flex;
      gap: 30px;
      padding: 15px 20px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      color: #888;
    }

    .stat-value {
      font-size: 18px;
      font-weight: bold;
      color: #4CAF50;
    }

    .button-row {
      display: flex;
      gap: 15px;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    button {
      background: #9C27B0;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: background 0.3s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    button:hover {
      background: #7B1FA2;
    }

    button.secondary {
      background: #2196F3;
    }

    button.secondary:hover {
      background: #1976D2;
    }

    button.success {
      background: #4CAF50;
    }

    button.success:hover {
      background: #388E3C;
    }

    button:disabled {
      background: #555;
      cursor: not-allowed;
    }

    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      font-size: 14px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #888;
    }

    .status-dot.connected {
      background: #4CAF50;
      animation: pulse 2s infinite;
    }

    .status-dot.loading {
      background: #FF9800;
      animation: pulse 0.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .filter-section {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      align-items: flex-end;
    }

    .range-filter {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .range-filter input[type="range"] {
      width: 150px;
    }

    .range-value {
      min-width: 50px;
      text-align: center;
      font-weight: bold;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #888;
    }

    .empty-state h3 {
      margin-bottom: 10px;
      color: #aaa;
    }

    /* Color coding for Y-axis series */
    .series-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      display: inline-block;
      margin-right: 6px;
    }

    /* Expression builder styles */
    .expression-builder {
      position: relative;
    }

    .expression-builder input[type="text"] {
      width: 100%;
      font-family: 'Courier New', monospace;
      font-size: 13px;
    }

    .expression-helpers {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .helper-btn {
      background: rgba(156, 39, 176, 0.3);
      color: #fff;
      border: 1px solid rgba(156, 39, 176, 0.5);
      padding: 4px 10px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }

    .helper-btn:hover {
      background: rgba(156, 39, 176, 0.5);
    }

    .remove-btn {
      background: rgba(244, 67, 54, 0.3);
      color: #fff;
      border: 1px solid rgba(244, 67, 54, 0.5);
      padding: 4px 10px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      position: absolute;
      right: 0;
      top: 0;
      transition: background 0.2s;
    }

    .remove-btn:hover {
      background: rgba(244, 67, 54, 0.5);
    }

    .add-btn {
      background: rgba(76, 175, 80, 0.3);
      color: #fff;
      border: 1px solid rgba(76, 175, 80, 0.5);
      padding: 6px 12px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }

    .add-btn:hover {
      background: rgba(76, 175, 80, 0.5);
    }

    #yAxisExpressions .expression-builder {
      margin-bottom: 12px;
      position: relative;
    }

    #yAxisExpressions .expression-builder:first-child .remove-btn {
      display: none;
    }

    #yAxisExpressions .expression-builder:not(:first-child) .remove-btn {
      display: block;
    }

    .column-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: rgba(26, 26, 46, 0.95);
      border: 1px solid rgba(156, 39, 176, 0.3);
      border-radius: 4px;
      margin-top: 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 100;
      display: none;
    }

    .column-suggestions.show {
      display: block;
    }

    .suggestion-item {
      padding: 8px 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .suggestion-item:hover {
      background: rgba(156, 39, 176, 0.2);
    }

    .expression-error {
      color: #f44336;
      font-size: 11px;
      margin-top: 4px;
    }
  </style>
</head>
<body>

<div class="container">
  <h1>ðŸ”¬ Advanced Analysis</h1>
  
  <div class="nav-links">
    <a href="/">Dashboard</a>
    <a href="/controls">Controls</a>
    <a href="/graph">Live Graph</a>
    <a href="/explorer">Data Explorer</a>
    <a href="/advanced" class="active">Advanced</a>
  </div>

  <!-- Data Source Section -->
  <div class="section">
    <div class="section-title">Data Source</div>
    <div class="controls-row">
      <div class="radio-group">
        <div class="radio-item">
          <input type="radio" id="sourceLive" name="dataSource" value="live">
          <label for="sourceLive">Live Data</label>
        </div>
        <div class="radio-item">
          <input type="radio" id="sourceSession" name="dataSource" value="session" checked>
          <label for="sourceSession">Load Session</label>
        </div>
      </div>
      <div class="control-group">
        <select id="sessionSelect">
          <option value="">-- Select a session --</option>
        </select>
      </div>
      <div class="status-indicator">
        <span class="status-dot" id="statusDot"></span>
        <span id="statusText">No data loaded</span>
      </div>
    </div>
  </div>

  <!-- Axis Configuration Section -->
  <div class="section">
    <div class="section-title">Axis Configuration</div>
    <div class="controls-row">
      <div class="control-group" style="flex: 1; min-width: 300px;">
        <label>X-Axis Expression</label>
        <div class="expression-builder">
          <input type="text" id="xAxisExpression" value="timestamp" placeholder="e.g., fan_speed or (delta_heater / delta_radiator)">
          <div class="expression-helpers" id="xAxisHelpers">
            <!-- Helper buttons will be generated by JavaScript -->
          </div>
          <div class="column-suggestions" id="xAxisSuggestions"></div>
        </div>
      </div>
      <div class="control-group" style="flex: 1; min-width: 300px;">
        <label>Y-Axis Expressions (add multiple)</label>
        <div id="yAxisExpressions">
          <div class="expression-builder">
            <input type="text" class="y-axis-expression" value="delta_water_radiator" placeholder="e.g., delta_water_radiator or (delta_heater / delta_radiator)">
            <button type="button" class="remove-btn" onclick="removeYAxis(this)" style="display: none;">Ã—</button>
            <div class="expression-helpers">
              <!-- Helper buttons will be generated by JavaScript -->
            </div>
          </div>
        </div>
        <button type="button" class="add-btn" onclick="addYAxis()" style="margin-top: 10px;">+ Add Y-Axis</button>
      </div>
    </div>
  </div>

  <!-- Filters Section -->
  <div class="section">
    <div class="section-title">Filters</div>
    <div class="filter-section">
      <div class="control-group">
        <label>Fan Speed Range</label>
        <div class="range-filter">
          <input type="number" id="fanSpeedMin" value="0" min="0" max="100" style="width: 70px;">
          <span>to</span>
          <input type="number" id="fanSpeedMax" value="100" min="0" max="100" style="width: 70px;">
        </div>
      </div>
      <div class="control-group">
        <label>Flow Mode</label>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="filter_main" value="main" checked>
            <label for="filter_main">Main</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="filter_diversion" value="diversion" checked>
            <label for="filter_diversion">Diversion</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="filter_mix" value="mix" checked>
            <label for="filter_mix">Mix</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="filter_none" value="none" checked>
            <label for="filter_none">None</label>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Display Options Section -->
  <div class="section">
    <div class="section-title">Display Options</div>
    <div class="controls-row">
      <div class="checkbox-item">
        <input type="checkbox" id="showTrendline" checked>
        <label for="showTrendline">Show Trendline</label>
      </div>
      <div class="radio-group">
        <div class="radio-item">
          <input type="radio" id="displayAll" name="displayMode" value="all" checked>
          <label for="displayAll">Show All Points</label>
        </div>
        <div class="radio-item">
          <input type="radio" id="displayAvg" name="displayMode" value="average">
          <label for="displayAvg">Show Averages</label>
        </div>
      </div>
    </div>
  </div>

  <!-- Chart Section -->
  <div class="section">
    <div class="chart-container">
      <canvas id="analysisChart"></canvas>
    </div>
    <div class="stats-bar" id="statsBar">
      <div class="stat-item">
        <span class="stat-label">Data Points</span>
        <span class="stat-value" id="statPoints">--</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">X Range</span>
        <span class="stat-value" id="statXRange">--</span>
      </div>
      <div class="stat-item" id="trendlineStats" style="display: none;">
        <span class="stat-label">RÂ² (Correlation)</span>
        <span class="stat-value" id="statR2">--</span>
      </div>
    </div>
  </div>

  <!-- Action Buttons -->
  <div class="button-row">
    <button class="success" onclick="updateChart()">
      ðŸ“Š Update Chart
    </button>
    <button class="secondary" onclick="exportFiltered()">
      ðŸ’¾ Export Filtered CSV
    </button>
    <button onclick="resetFilters()">
      ðŸ”„ Reset Filters
    </button>
  </div>
</div>

<script>
// Global state
let rawData = [];
let filteredData = [];
let chart = null;
let ws = null;
let liveMode = false;

// Available column names for expressions
const availableColumns = [
  'timestamp', 'water_hot', 'water_reservoir', 'water_mix', 'water_cold',
  'air_cool', 'air_heated', 'delta_water_heater', 'delta_water_radiator',
  'delta_air', 'flow_rate', 'fan_speed', 'main_loop_state', 'diversion_state',
  'control_mode', 'flow_mode'
];

// Column display names
const columnDisplayNames = {
  'timestamp': 'Time',
  'water_hot': 'Water Hot',
  'water_reservoir': 'Water Reservoir',
  'water_mix': 'Water Mix',
  'water_cold': 'Water Cold',
  'air_cool': 'Air Cool',
  'air_heated': 'Air Heated',
  'delta_water_heater': 'Delta Heater',
  'delta_water_radiator': 'Delta Radiator',
  'delta_air': 'Delta Air',
  'flow_rate': 'Flow Rate',
  'fan_speed': 'Fan Speed',
  'main_loop_state': 'Main Loop',
  'diversion_state': 'Diversion',
  'control_mode': 'Control Mode',
  'flow_mode': 'Flow Mode'
};

// Series colors
const seriesColors = {
  delta_water_radiator: '#4CAF50',
  delta_water_heater: '#FF5722',
  delta_air: '#2196F3',
  water_hot: '#f44336',
  water_mix: '#FF9800',
  water_cold: '#03A9F4',
  water_reservoir: '#9C27B0',
  air_cool: '#00BCD4',
  air_heated: '#E91E63',
  fan_speed: '#FFC107',
  flow_rate: '#8BC34A'
};

// Helper button definitions (same for X and Y axes)
const helperButtons = [
  { value: 'timestamp', label: 'Time' },
  { value: 'fan_speed', label: 'Fan' },
  { value: 'flow_rate', label: 'Flow' },
  { value: 'delta_water_heater', label: 'Î” Heat' },
  { value: 'delta_water_radiator', label: 'Î” Rad' },
  { value: 'delta_air', label: 'Î” Air' },
  { value: 'water_hot', label: 'Hot' },
  { value: 'water_mix', label: 'Mix' },
  { value: 'water_cold', label: 'Cold' },
  { value: 'water_reservoir', label: 'Res' },
  { value: 'air_heated', label: 'Air H' },
  { value: 'air_cool', label: 'Air C' },
  { value: '(', label: '(' },
  { value: ')', label: ')' },
  { value: ' + ', label: '+' },
  { value: ' - ', label: '-' },
  { value: ' * ', label: 'Ã—' },
  { value: ' / ', label: '/' }
];

// Generate helper buttons HTML for X-axis
function generateXAxisHelpers() {
  const container = document.getElementById('xAxisHelpers');
  if (!container) return;
  
  container.innerHTML = helperButtons.map(btn => {
    // Escape single quotes and backslashes for onclick attribute
    const escapedValue = btn.value.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
    return `<button type="button" class="helper-btn" onclick="insertIntoXAxis('${escapedValue}')">${btn.label}</button>`;
  }).join('');
}

// Generate helper buttons HTML for Y-axis
function generateYAxisHelpers(container) {
  if (!container) return;
  
  container.innerHTML = helperButtons.map(btn => {
    // Escape single quotes and backslashes for onclick attribute
    const escapedValue = btn.value.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
    return `<button type="button" class="helper-btn" onclick="insertIntoYAxis(this, '${escapedValue}')">${btn.label}</button>`;
  }).join('');
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
  loadSessionList();
  initChart();
  
  // Generate helper buttons
  generateXAxisHelpers();
  document.querySelectorAll('#yAxisExpressions .expression-helpers').forEach(container => {
    generateYAxisHelpers(container);
  });
  
  // Event listeners
  document.querySelectorAll('input[name="dataSource"]').forEach(radio => {
    radio.addEventListener('change', handleDataSourceChange);
  });
  
  document.getElementById('sessionSelect').addEventListener('change', loadSessionData);
  
  // Expression input handlers
  document.getElementById('xAxisExpression').addEventListener('input', handleExpressionInput);
  document.getElementById('xAxisExpression').addEventListener('focus', showColumnSuggestions);
  document.getElementById('xAxisExpression').addEventListener('blur', () => {
    setTimeout(() => hideColumnSuggestions(), 200);
  });
});

// Safe expression evaluator
function evaluateExpression(expression, dataPoint) {
  if (!expression || expression.trim() === '') {
    return null;
  }
  
  const expr = expression.trim();
  
  // Handle special case: timestamp
  if (expr === 'timestamp') {
    return new Date(dataPoint.timestamp).getTime();
  }
  
  // Shortcut: If expression is just a simple column name, return it directly
  if (availableColumns.includes(expr)) {
    const directValue = dataPoint[expr];
    
    // Check if value exists and is not null/undefined/empty string
    if (directValue === undefined || directValue === null || directValue === '') {
      console.warn(`Column "${expr}" not found, is null, or is empty in data point. Value:`, directValue, `Type:`, typeof directValue, `Available keys:`, Object.keys(dataPoint));
      return null;
    }
    
    // Convert to number if needed
    let numValue;
    if (typeof directValue === 'boolean') {
      numValue = directValue ? 1 : 0;
    } else if (typeof directValue === 'number') {
      numValue = directValue;
    } else if (typeof directValue === 'string') {
      // Handle empty strings or "None" strings
      if (directValue.trim() === '' || directValue.toLowerCase() === 'none') {
        return null;
      }
      numValue = parseFloat(directValue);
    } else {
      numValue = parseFloat(directValue);
    }
    
    // Return the value (including zero, which is valid)
    if (!isNaN(numValue) && isFinite(numValue)) {
      return numValue;
    }
    console.warn(`Column "${expr}" could not be converted to number. Value:`, directValue, `Type:`, typeof directValue);
    return null;
  }
  
  // Replace column names with their values
  let processedExpr = expr;
  
  // Replace column names with values (case-sensitive, whole word)
  // Process in reverse order to avoid partial matches (e.g., delta_water_heater before delta)
  const sortedColumns = [...availableColumns].sort((a, b) => b.length - a.length);
  
  for (const col of sortedColumns) {
    // Use word boundaries to match whole column names only
    const regex = new RegExp(`\\b${col.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'g');
    const value = dataPoint[col];
    
    if (value !== undefined && value !== null) {
      // Convert boolean to number if needed
      let numValue;
      if (typeof value === 'boolean') {
        numValue = value ? 1 : 0;
      } else if (typeof value === 'number') {
        numValue = value;
      } else {
        numValue = parseFloat(value);
      }
      
      // Allow zero values (they're valid numbers)
      if (!isNaN(numValue) && isFinite(numValue)) {
        processedExpr = processedExpr.replace(regex, numValue.toString());
      } else {
        // If value is not numeric, return null
        console.warn(`Column "${col}" has non-numeric value:`, value, typeof value);
        return null;
      }
    } else {
      // Column not found in data point - this is a problem
      if (regex.test(expr)) {
        console.warn(`Column "${col}" not found in data point. Available keys:`, Object.keys(dataPoint));
      }
    }
  }
  
  // Check if there are any remaining column names that weren't replaced
  // This catches typos like "delta_water_heatertimestamp" (missing operator)
  const remainingColumns = availableColumns.filter(col => {
    const regex = new RegExp(`\\b${col.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`);
    return regex.test(processedExpr);
  });
  
  if (remainingColumns.length > 0) {
    console.warn(`Expression contains unmatched column names: ${remainingColumns.join(', ')}`);
    // This might be okay if it's part of a longer identifier, but likely a typo
  }
  
  // Validate expression contains only safe characters (numbers, operators, parentheses, spaces, dots)
  const safePattern = /^[0-9+\-*/().\s]+$/;
  if (!safePattern.test(processedExpr)) {
    // If there are still non-numeric characters, the expression might be invalid
    // Check if it's just whitespace or if there are unmatched column names
    const cleaned = processedExpr.replace(/\s/g, '');
    if (!/^[0-9+\-*/().]+$/.test(cleaned)) {
      console.warn(`Expression contains invalid characters after substitution: "${processedExpr}"`);
      return null;
    }
  }
  
  // Evaluate the expression safely
  try {
    // Use Function constructor for safer evaluation (still limited to math)
    // Wrap in try-catch to handle division by zero, infinity, etc.
    const result = Function('"use strict"; return (' + processedExpr + ')')();
    
    // Check for valid numeric result
    // Explicitly check for NaN, Infinity, and -Infinity
    if (typeof result === 'number') {
      if (isNaN(result)) {
        // NaN - likely 0/0 or invalid operation
        return NaN; // Return NaN so caller can track it
      } else if (!isFinite(result) || result === Infinity || result === -Infinity) {
        // Infinity - likely division by zero
        return Infinity; // Return Infinity so caller can track it
      } else {
        // Valid finite number
        return result;
      }
    }
    return null;
  } catch (error) {
    // Syntax errors or other errors
    console.warn(`Expression evaluation error for "${expr}":`, error, `Processed: "${processedExpr}"`);
    return null;
  }
}

// Insert text into X-axis expression
function insertIntoXAxis(text) {
  const input = document.getElementById('xAxisExpression');
  const start = input.selectionStart;
  const end = input.selectionEnd;
  const current = input.value;
  input.value = current.substring(0, start) + text + current.substring(end);
  input.selectionStart = input.selectionEnd = start + text.length;
  input.focus();
}

// Insert text into Y-axis expression
function insertIntoYAxis(button, text) {
  const expressionBuilder = button.closest('.expression-builder');
  const input = expressionBuilder.querySelector('.y-axis-expression');
  const start = input.selectionStart;
  const end = input.selectionEnd;
  const current = input.value;
  input.value = current.substring(0, start) + text + current.substring(end);
  input.selectionStart = input.selectionEnd = start + text.length;
  input.focus();
}

// Add new Y-axis expression
function addYAxis() {
  const container = document.getElementById('yAxisExpressions');
  const newExpr = document.createElement('div');
  newExpr.className = 'expression-builder';
  newExpr.innerHTML = `
    <input type="text" class="y-axis-expression" value="" placeholder="e.g., delta_water_radiator or (delta_heater / delta_radiator)">
    <button type="button" class="remove-btn" onclick="removeYAxis(this)">Ã—</button>
    <div class="expression-helpers">
      <!-- Helper buttons will be generated by JavaScript -->
    </div>
  `;
  container.appendChild(newExpr);
  // Generate helper buttons for the new expression
  const helpersContainer = newExpr.querySelector('.expression-helpers');
  generateYAxisHelpers(helpersContainer);
}

// Remove Y-axis expression
function removeYAxis(button) {
  const expressionBuilder = button.closest('.expression-builder');
  expressionBuilder.remove();
}

// Show column suggestions
function showColumnSuggestions(e) {
  const input = e.target;
  const suggestions = document.getElementById('xAxisSuggestions');
  const value = input.value.toLowerCase();
  
  // Filter columns that match
  const matches = availableColumns.filter(col => 
    col.toLowerCase().includes(value) || 
    (columnDisplayNames[col] && columnDisplayNames[col].toLowerCase().includes(value))
  );
  
  if (matches.length === 0) {
    suggestions.classList.remove('show');
    return;
  }
  
  suggestions.innerHTML = matches.map(col => 
    `<div class="suggestion-item" onclick="selectSuggestion('${col}')">${columnDisplayNames[col] || col}</div>`
  ).join('');
  
  suggestions.classList.add('show');
}

// Hide column suggestions
function hideColumnSuggestions() {
  document.getElementById('xAxisSuggestions').classList.remove('show');
}

// Select a suggestion
function selectSuggestion(column) {
  const input = document.getElementById('xAxisExpression');
  input.value = column;
  input.focus();
  hideColumnSuggestions();
}

// Handle expression input
function handleExpressionInput(e) {
  // Could add real-time validation here
}

// Load available sessions
async function loadSessionList() {
  try {
    const response = await fetch('/api/sessions');
    const data = await response.json();
    
    const select = document.getElementById('sessionSelect');
    select.innerHTML = '<option value="">-- Select a session --</option>';
    
    data.sessions.forEach(session => {
      const option = document.createElement('option');
      option.value = session.filename;
      option.textContent = session.filename;
      select.appendChild(option);
    });
  } catch (error) {
    console.error('Error loading sessions:', error);
  }
}

// Handle data source change
function handleDataSourceChange(e) {
  const isLive = e.target.value === 'live';
  document.getElementById('sessionSelect').disabled = isLive;
  
  if (isLive) {
    startLiveMode();
  } else {
    stopLiveMode();
  }
}

// Start live data mode
function startLiveMode() {
  liveMode = true;
  rawData = [];
  
  const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);
  
  ws.onopen = () => {
    setStatus('connected', 'Live - Collecting data...');
  };
  
  ws.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      
      // Convert to flat data point
      const point = {
        timestamp: new Date().toISOString(),
        water_hot: data.temperatures?.water_hot,
        water_reservoir: data.temperatures?.water_reservoir,
        water_mix: data.temperatures?.water_mix,
        water_cold: data.temperatures?.water_cold,
        air_cool: data.temperatures?.air_cool,
        air_heated: data.temperatures?.air_heated,
        delta_water_heater: data.deltas?.water_heater,
        delta_water_radiator: data.deltas?.water_radiator,
        delta_air: data.deltas?.air,
        flow_rate: data.flow_rate,
        fan_speed: data.fan_speed,
        flow_mode: data.flow_mode || 'none'
      };
      
      rawData.push(point);
      setStatus('connected', `Live - ${rawData.length} points`);
      
      // Auto-update chart every 10 points
      if (rawData.length % 10 === 0) {
        updateChart();
      }
    } catch (error) {
      console.error('Error parsing live data:', error);
    }
  };
  
  ws.onclose = () => {
    setStatus('', 'Disconnected');
    liveMode = false;
  };
}

// Stop live data mode
function stopLiveMode() {
  liveMode = false;
  if (ws) {
    ws.close();
    ws = null;
  }
  setStatus('', 'No data loaded');
}

// Load session data
async function loadSessionData() {
  const filename = document.getElementById('sessionSelect').value;
  if (!filename) return;
  
  setStatus('loading', 'Loading...');
  
  try {
    const response = await fetch(`/api/session_data/${encodeURIComponent(filename)}`);
    const data = await response.json();
    
    if (data.error) {
      setStatus('', `Error: ${data.error}`);
      return;
    }
    
    rawData = data.data;
    console.log(`âœ… Loaded ${rawData.length} data points`);
    
    // Debug: Show first data point structure
    if (rawData.length > 0) {
      console.log('ðŸ“Š First data point structure:', rawData[0]);
      console.log('ðŸ“Š Available columns:', Object.keys(rawData[0]));
      console.log('ðŸ“Š Sample delta_water_radiator value:', rawData[0].delta_water_radiator, typeof rawData[0].delta_water_radiator);
      console.log('ðŸ“Š Sample delta_water_heater value:', rawData[0].delta_water_heater, typeof rawData[0].delta_water_heater);
    }
    
    setStatus('connected', `Loaded ${rawData.length} points`);
    updateChart();
  } catch (error) {
    console.error('Error loading session:', error);
    setStatus('', 'Error loading session');
  }
}

// Set status indicator
function setStatus(state, text) {
  const dot = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');
  
  dot.className = 'status-dot ' + state;
  statusText.textContent = text;
}

// Initialize Chart.js
function initChart() {
  const ctx = document.getElementById('analysisChart').getContext('2d');
  
  chart = new Chart(ctx, {
    type: 'scatter',
    data: {
      datasets: []
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'top',
          labels: { color: '#fff' }
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              return `${context.dataset.label}: (${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
            }
          }
        }
      },
      scales: {
        x: {
          title: {
            display: true,
            text: 'Time',
            color: '#fff'
          },
          ticks: { color: '#aaa' },
          grid: { color: 'rgba(255,255,255,0.1)' }
        },
        y: {
          title: {
            display: true,
            text: 'Value',
            color: '#fff'
          },
          ticks: { color: '#aaa' },
          grid: { color: 'rgba(255,255,255,0.1)' }
        }
      }
    }
  });
}

// Apply filters to data
function applyFilters() {
  const fanMin = parseFloat(document.getElementById('fanSpeedMin').value) || 0;
  const fanMax = parseFloat(document.getElementById('fanSpeedMax').value) || 100;
  
  const allowedModes = [];
  if (document.getElementById('filter_main').checked) allowedModes.push('main');
  if (document.getElementById('filter_diversion').checked) allowedModes.push('diversion');
  if (document.getElementById('filter_mix').checked) allowedModes.push('mix');
  if (document.getElementById('filter_none').checked) allowedModes.push('none');
  
  filteredData = rawData.filter(point => {
    const fanOk = point.fan_speed >= fanMin && point.fan_speed <= fanMax;
    const modeOk = allowedModes.includes(point.flow_mode);
    return fanOk && modeOk;
  });
  
  return filteredData;
}

// Calculate linear regression
function linearRegression(points) {
  const n = points.length;
  if (n < 2) return null;
  
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
  
  points.forEach(p => {
    sumX += p.x;
    sumY += p.y;
    sumXY += p.x * p.y;
    sumX2 += p.x * p.x;
    sumY2 += p.y * p.y;
  });
  
  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  
  // Calculate RÂ²
  const yMean = sumY / n;
  let ssTotal = 0, ssResidual = 0;
  points.forEach(p => {
    ssTotal += Math.pow(p.y - yMean, 2);
    const predicted = slope * p.x + intercept;
    ssResidual += Math.pow(p.y - predicted, 2);
  });
  
  const r2 = 1 - (ssResidual / ssTotal);
  
  return { slope, intercept, r2 };
}

// Update the chart
function updateChart() {
  console.log('ðŸ“Š updateChart called');
  
  try {
    const data = applyFilters();
    console.log(`Filtered data points: ${data.length}`);
    
    if (data.length === 0) {
      document.getElementById('statPoints').textContent = '0';
      alert('No data points after filtering. Check your filters.');
      return;
    }
    
    const xAxisExpression = document.getElementById('xAxisExpression').value.trim();
    const showTrendline = document.getElementById('showTrendline').checked;
    const displayMode = document.querySelector('input[name="displayMode"]:checked').value;
    
    console.log(`X-axis expression: "${xAxisExpression}"`);
    
    if (!xAxisExpression) {
      alert('Please enter an X-axis expression');
      return;
    }
    
    // Get Y-axis expressions
    const yExpressions = [];
    document.querySelectorAll('.y-axis-expression').forEach(input => {
      const expr = input.value.trim();
      if (expr) {
        yExpressions.push(expr);
        console.log(`Y-axis expression: "${expr}"`);
      }
    });
    
    if (yExpressions.length === 0) {
      alert('Please enter at least one Y-axis expression');
      return;
    }
    
    // Prepare datasets
    const datasets = [];
    let allR2 = [];
    
    // Evaluate X values for all points
    console.log('Evaluating X-axis values...');
    const xValues = data.map((d, idx) => {
      const x = evaluateExpression(xAxisExpression, d);
      if (idx < 3) {
        console.log(`  Point ${idx}: x=${x}, sample data:`, {
          timestamp: d.timestamp,
          delta_water_heater: d.delta_water_heater,
          delta_water_radiator: d.delta_water_radiator
        });
      }
      return { data: d, x: x };
    }).filter(p => p.x !== null && !isNaN(p.x) && isFinite(p.x));
    
    console.log(`Valid X values: ${xValues.length} out of ${data.length}`);
    
    if (xValues.length === 0) {
      const errorMsg = `X-axis expression "${xAxisExpression}" returned no valid values.\n\n` +
        `Possible issues:\n` +
        `- Check for typos in column names\n` +
        `- Ensure column names are separated by operators\n` +
        `- Example: "(delta_water_heater / delta_water_radiator)" not "delta_water_heatertimestamp"`;
      alert(errorMsg);
      return;
    }
  
  // Handle timestamp special case for display
  const isTimeBased = xAxisExpression.trim() === 'timestamp';
  let processedXValues = xValues;
  
  if (isTimeBased) {
    // Convert timestamps to seconds from start
    const startTime = xValues[0].x;
    processedXValues = xValues.map(p => ({
      data: p.data,
      x: (p.x - startTime) / 1000 // seconds from start
    }));
  }
  
  yExpressions.forEach((yExpr, idx) => {
    console.log(`Evaluating Y-axis expression ${idx + 1}: "${yExpr}"`);
    
    // Evaluate Y values
    let validCount = 0;
    let invalidCount = 0;
    let divisionByZeroCount = 0;
    let nanCount = 0;
    let infinityCount = 0;
    
    let points = processedXValues.map((p, pointIdx) => {
      const y = evaluateExpression(yExpr, p.data);
      
      // Debug first few evaluations
      if (pointIdx < 5) {
        console.log(`  Evaluating point ${pointIdx}:`, {
          expression: yExpr,
          delta_heater: p.data.delta_water_heater,
          delta_radiator: p.data.delta_water_radiator,
          result: y,
          resultType: typeof y,
          isNaN: isNaN(y),
          isFinite: isFinite(y),
          isInfinity: (y === Infinity || y === -Infinity)
        });
      }
      
      if (y !== null && !isNaN(y) && isFinite(y) && y !== Infinity && y !== -Infinity) {
        validCount++;
        if (pointIdx < 3) {
          console.log(`  âœ… Point ${pointIdx}: y=${y}, x=${p.x}`);
        }
        return { x: p.x, y: y };
      } else {
        invalidCount++;
        if (y === Infinity || y === -Infinity) {
          infinityCount++;
          if (pointIdx < 3) {
            console.warn(`  âŒ Point ${pointIdx}: Division by zero (Infinity) - delta_heater=${p.data.delta_water_heater}, delta_radiator=${p.data.delta_water_radiator}`);
          }
        } else if (isNaN(y)) {
          nanCount++;
          if (pointIdx < 3) {
            console.warn(`  âŒ Point ${pointIdx}: NaN result - delta_heater=${p.data.delta_water_heater}, delta_radiator=${p.data.delta_water_radiator}`);
          }
        } else if (y === null) {
          if (pointIdx < 3) {
            console.warn(`  âŒ Point ${pointIdx}: null result - expression may have failed to evaluate`);
          }
        }
        return null;
      }
    }).filter(p => p !== null);
    
    console.log(`Valid Y values for expression "${yExpr}": ${points.length} out of ${processedXValues.length}`);
    if (invalidCount > 0) {
      console.log(`  Invalid values breakdown: ${invalidCount} total, ${infinityCount} Infinity (division by zero), ${nanCount} NaN, ${invalidCount - infinityCount - nanCount} other`);
    }
    
    if (points.length === 0) {
      let errorMsg = `Y-axis expression "${yExpr}" returned no valid values.\n\n`;
      
      if (infinityCount > 0) {
        errorMsg += `âš ï¸ ${infinityCount} values were filtered due to division by zero.\n`;
        errorMsg += `   This happens when delta_water_radiator = 0.\n\n`;
      }
      if (nanCount > 0) {
        errorMsg += `âš ï¸ ${nanCount} values were NaN (0/0 or invalid operation).\n\n`;
      }
      
      errorMsg += `Possible solutions:\n`;
      errorMsg += `- Filter out rows where delta_water_radiator = 0\n`;
      errorMsg += `- Use a different expression that avoids division by zero\n`;
      errorMsg += `- Check your data - are delta values being calculated correctly?`;
      
      alert(errorMsg);
      return;
    }
    
    // Apply averaging if selected and X is not time
    if (displayMode === 'average' && !isTimeBased) {
      const grouped = {};
      points.forEach(p => {
        const key = p.x.toFixed(2);
        if (!grouped[key]) grouped[key] = [];
        grouped[key].push(p.y);
      });
      
      points = Object.entries(grouped).map(([x, ys]) => ({
        x: parseFloat(x),
        y: ys.reduce((a, b) => a + b, 0) / ys.length
      }));
    }
    
    // Generate color for this series
    const colorKeys = Object.keys(seriesColors);
    const colorIndex = idx % colorKeys.length;
    const colorKey = colorKeys[colorIndex];
    const color = seriesColors[colorKey] || '#9C27B0';
    
    // Create label from expression
    const label = yExpr.length > 30 ? yExpr.substring(0, 27) + '...' : yExpr;
    
    // Main data series
    datasets.push({
      label: label,
      data: points,
      backgroundColor: color + '80',
      borderColor: color,
      pointRadius: isTimeBased ? 2 : 4,
      showLine: isTimeBased,
      fill: false
    });
    
    // Trendline
    if (showTrendline && points.length >= 2) {
      const regression = linearRegression(points);
      if (regression && !isNaN(regression.slope)) {
        const xMin = Math.min(...points.map(p => p.x));
        const xMax = Math.max(...points.map(p => p.x));
        
        datasets.push({
          label: `${label} trendline (RÂ²=${regression.r2.toFixed(3)})`,
          data: [
            { x: xMin, y: regression.slope * xMin + regression.intercept },
            { x: xMax, y: regression.slope * xMax + regression.intercept }
          ],
          borderColor: color,
          borderWidth: 2,
          borderDash: [5, 5],
          pointRadius: 0,
          showLine: true,
          fill: false
        });
        
        allR2.push({ expr: yExpr, r2: regression.r2 });
      }
    }
  });
  
  // Update chart
  if (datasets.length === 0) {
    alert('No valid data series to display. Check your Y-axis expressions.');
    console.error('No datasets created');
    return;
  }
  
  chart.data.datasets = datasets;
  
  // Set X-axis label
  if (isTimeBased) {
    chart.options.scales.x.title.text = 'Time (seconds)';
  } else {
    const label = xAxisExpression.length > 30 ? xAxisExpression.substring(0, 27) + '...' : xAxisExpression;
    chart.options.scales.x.title.text = label;
  }
  
  chart.update();
  console.log(`âœ… Chart updated with ${datasets.length} dataset(s)`);
  
  // Update stats
  document.getElementById('statPoints').textContent = data.length;
  
  if (!isTimeBased) {
    const xNums = processedXValues.map(p => p.x).filter(v => !isNaN(v) && isFinite(v));
    if (xNums.length > 0) {
      const xMin = Math.min(...xNums).toFixed(2);
      const xMax = Math.max(...xNums).toFixed(2);
      document.getElementById('statXRange').textContent = `${xMin} - ${xMax}`;
    } else {
      document.getElementById('statXRange').textContent = '--';
    }
  } else {
    const duration = (processedXValues[processedXValues.length - 1].x - processedXValues[0].x);
    document.getElementById('statXRange').textContent = `${duration.toFixed(0)}s`;
  }
  
  // Show RÂ² stats
  if (allR2.length > 0) {
    document.getElementById('trendlineStats').style.display = 'block';
    const avgR2 = allR2.reduce((sum, r) => sum + r.r2, 0) / allR2.length;
    document.getElementById('statR2').textContent = avgR2.toFixed(3);
  } else {
    document.getElementById('trendlineStats').style.display = 'none';
  }
  } catch (error) {
    console.error('Error in updateChart:', error);
    alert(`Error updating chart: ${error.message}\n\nCheck the browser console for details.`);
  }
}

// Export filtered data
async function exportFiltered() {
  if (filteredData.length === 0) {
    alert('No data to export. Load a session first.');
    return;
  }
  
  // Create CSV content
  const headers = Object.keys(filteredData[0]);
  const csvContent = [
    headers.join(','),
    ...filteredData.map(row => headers.map(h => row[h]).join(','))
  ].join('\n');
  
  // Download
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `analysis_export_${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Reset filters
function resetFilters() {
  document.getElementById('fanSpeedMin').value = 0;
  document.getElementById('fanSpeedMax').value = 100;
  document.getElementById('filter_main').checked = true;
  document.getElementById('filter_diversion').checked = true;
  document.getElementById('filter_mix').checked = true;
  document.getElementById('filter_none').checked = true;
  document.getElementById('showTrendline').checked = true;
  document.getElementById('displayAll').checked = true;
  
  // Reset expressions
  document.getElementById('xAxisExpression').value = 'timestamp';
  
  // Reset Y-axis expressions to single default
  const yContainer = document.getElementById('yAxisExpressions');
  yContainer.innerHTML = `
    <div class="expression-builder">
      <input type="text" class="y-axis-expression" value="delta_water_radiator" placeholder="e.g., delta_water_radiator or (delta_heater / delta_radiator)">
      <button type="button" class="remove-btn" onclick="removeYAxis(this)" style="display: none;">Ã—</button>
      <div class="expression-helpers">
        <!-- Helper buttons will be generated by JavaScript -->
      </div>
    </div>
  `;
  // Generate helper buttons for the reset expression
  const helpersContainer = yContainer.querySelector('.expression-helpers');
  generateYAxisHelpers(helpersContainer);
  
  if (rawData.length > 0) {
    updateChart();
  }
}
</script>

</body>
</html>
